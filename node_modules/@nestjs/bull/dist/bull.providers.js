"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createQueueProviders = exports.createQueueOptionProviders = void 0;
const common_1 = require("@nestjs/common");
const Bull = require("bull");
const helpers_1 = require("./helpers");
const utils_1 = require("./utils");
const helpers_2 = require("./utils/helpers");
function buildQueue(option) {
    const queue = new Bull(option.name ? option.name : 'default', option);
    if (option.processors) {
        option.processors.forEach((processor) => {
            let args = [];
            if (helpers_2.isAdvancedProcessor(processor)) {
                args.push(processor.name, processor.concurrency, processor.callback);
            }
            else if (helpers_2.isAdvancedSeparateProcessor(processor)) {
                args.push(processor.name, processor.concurrency, processor.path);
            }
            else if (helpers_2.isSeparateProcessor(processor)) {
                args.push(processor);
            }
            else if (helpers_2.isProcessorCallback(processor)) {
                args.push(processor);
            }
            args = args.filter((arg) => typeof arg !== 'undefined');
            queue.process.call(queue, ...args);
        });
    }
    queue.onApplicationShutdown = function () {
        return this.close();
    };
    return queue;
}
function createQueueOptionProviders(options) {
    const providers = options.map((option) => {
        const optionalSharedConfigHolder = helpers_1.createConditionalDepHolder(utils_1.getSharedConfigToken(option.configKey));
        return [
            optionalSharedConfigHolder,
            {
                provide: utils_1.getQueueOptionsToken(option.name),
                useFactory: (optionalDepHolder) => {
                    return Object.assign(Object.assign({}, optionalDepHolder.getDependencyRef(option.name)), option);
                },
                inject: [optionalSharedConfigHolder],
            },
        ];
    });
    return common_1.flatten(providers);
}
exports.createQueueOptionProviders = createQueueOptionProviders;
function createQueueProviders(options) {
    return options.map((option) => ({
        provide: utils_1.getQueueToken(option.name),
        useFactory: (o) => {
            const queueName = o.name || option.name;
            return buildQueue(Object.assign(Object.assign({}, o), { name: queueName }));
        },
        inject: [utils_1.getQueueOptionsToken(option.name)],
    }));
}
exports.createQueueProviders = createQueueProviders;
