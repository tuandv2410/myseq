import 'reflect-metadata';
import set from 'lodash.set';

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

/**
 * camelCase naming convention
 */
var CamelCaseNamingConvention = /*#__PURE__*/function () {
  function CamelCaseNamingConvention() {
    this.separatorCharacter = '';
    this.splittingExpression = /(^[a-z]+(?=$|[A-Z]{1}[a-z0-9]+)|[A-Z]?[a-z0-9]+)/;
  }

  var _proto = CamelCaseNamingConvention.prototype;

  _proto.transformPropertyName = function transformPropertyName(sourceNameParts) {
    var result = '';

    for (var i = 0, len = sourceNameParts.length; i < len; i++) {
      if (i === 0) {
        result += sourceNameParts[i].charAt(0).toLowerCase();
      } else {
        result += sourceNameParts[i].charAt(0).toUpperCase();
      }

      result += sourceNameParts[i].substr(1);
    }

    return result;
  };

  return CamelCaseNamingConvention;
}();

var SnakeCaseNamingConvention = /*#__PURE__*/function () {
  function SnakeCaseNamingConvention() {
    this.separatorCharacter = '_';
    this.splittingExpression = /_/;
  }

  var _proto = SnakeCaseNamingConvention.prototype;

  _proto.transformPropertyName = function transformPropertyName(sourcePropNameParts) {
    var len = sourcePropNameParts.length;

    if (len <= 1) {
      return sourcePropNameParts[0].toLowerCase() || '';
    }

    return sourcePropNameParts.map(function (p) {
      return p.toLowerCase();
    }).join(this.separatorCharacter);
  };

  return SnakeCaseNamingConvention;
}();

/**
 * PascalCase naming convention
 */
var PascalCaseNamingConvention = /*#__PURE__*/function () {
  function PascalCaseNamingConvention() {
    this.separatorCharacter = '';
    this.splittingExpression = /(^[A-Z]+(?=$|[A-Z]{1}[a-z0-9]+)|[A-Z]?[a-z0-9]+)/;
  }

  var _proto = PascalCaseNamingConvention.prototype;

  _proto.transformPropertyName = function transformPropertyName(sourceNameParts) {
    var result = '';

    for (var i = 0, len = sourceNameParts.length; i < len; i++) {
      result += sourceNameParts[i].charAt(0).toUpperCase() + sourceNameParts[i].substr(1);
    }

    return result;
  };

  return PascalCaseNamingConvention;
}();

var defaultNamingConvention = CamelCaseNamingConvention;

var ErrorHandler = /*#__PURE__*/function () {
  function ErrorHandler() {}

  ErrorHandler.setShouldThrow = function setShouldThrow(shouldThrow) {
    this.shouldThrow = shouldThrow;
  };

  ErrorHandler.handleError = function handleError(errorMessage) {
    if (this.shouldThrow) {
      throw new Error(errorMessage);
    } else {
      console.warn(errorMessage);
      return;
    }
  };

  return ErrorHandler;
}();
ErrorHandler.shouldThrow = true;

var NestStorage = /*#__PURE__*/function () {
  function NestStorage() {
    this.storage = new WeakMap();
  }

  var _proto = NestStorage.prototype;

  _proto.set = function set(key, nestedKey, value) {
    this.setInternal(this.storage, key, nestedKey, value);
  };

  _proto.get = function get(key, nestedKey) {
    return this.getInternal(this.storage, key, nestedKey);
  };

  _proto.has = function has(key, nestedKey) {
    return this.hasInternal(this.storage, key, nestedKey);
  };

  _proto.getInternal = function getInternal(storage, key, nestedKey) {
    var _storage$get;

    return (_storage$get = storage.get(key)) == null ? void 0 : _storage$get.get(nestedKey);
  };

  _proto.hasInternal = function hasInternal(storage, key, nestedKey) {
    var _storage$get2;

    return ((_storage$get2 = storage.get(key)) == null ? void 0 : _storage$get2.has(nestedKey)) || false;
  };

  return NestStorage;
}();
var WeakMapNestedStorage = /*#__PURE__*/function (_NestStorage) {
  _inheritsLoose(WeakMapNestedStorage, _NestStorage);

  function WeakMapNestedStorage() {
    return _NestStorage.call(this) || this;
  }

  var _proto2 = WeakMapNestedStorage.prototype;

  _proto2.dispose = function dispose() {
    this.storage = new WeakMap();
  };

  _proto2.setInternal = function setInternal(storage, key, nestedKey, value) {
    if (!storage.has(key)) {
      storage.set(key, new WeakMap().set(nestedKey, value));
      return;
    }

    if (!this.hasInternal(storage, key, nestedKey)) {
      storage.get(key).set(nestedKey, value);
    }
  };

  return WeakMapNestedStorage;
}(NestStorage);
var MapNestedStorage = /*#__PURE__*/function (_NestStorage2) {
  _inheritsLoose(MapNestedStorage, _NestStorage2);

  function MapNestedStorage() {
    return _NestStorage2.call(this) || this;
  }

  var _proto3 = MapNestedStorage.prototype;

  _proto3.setInternal = function setInternal(storage, key, nestedKey, value) {
    if (!storage.has(key)) {
      storage.set(key, new Map().set(nestedKey, value));
      return;
    }

    if (!this.hasInternal(storage, key, nestedKey)) {
      storage.get(key).set(nestedKey, value);
    }
  };

  return MapNestedStorage;
}(NestStorage);

/**
 * Internal MappingStorage class
 * @private
 */

var MappingStorage = /*#__PURE__*/function (_WeakMapNestedStorage) {
  _inheritsLoose(MappingStorage, _WeakMapNestedStorage);

  function MappingStorage() {
    return _WeakMapNestedStorage.call(this) || this;
  }

  return MappingStorage;
}(WeakMapNestedStorage);

/**
 * Internal MetadataStorage class
 *
 * @private
 */
var MetadataStorage = /*#__PURE__*/function () {
  function MetadataStorage() {
    this._metadataMap = new Map();
  }

  var _proto = MetadataStorage.prototype;

  _proto.getMetadata = function getMetadata(model) {
    var metadataMapList = this._metadataMap.get(model);

    var i = (metadataMapList == null ? void 0 : metadataMapList.length) || 0;

    if (!i) {
      var proto = Object.getPrototypeOf(model);
      return proto ? this.getMetadata(proto) : metadataMapList;
    }

    var result = [];

    var _loop = function _loop() {
      var _metadataMapList$i = metadataMapList[i],
          key = _metadataMapList$i[0];

      if (result.some(function (_ref) {
        var metaKey = _ref[0];
        return metaKey === key;
      })) {
        return "continue";
      }

      result.push(metadataMapList[i]);
    };

    while (i--) {
      var _ret = _loop();

      if (_ret === "continue") continue;
    }

    return result;
  };

  _proto.getMetadataForKey = function getMetadataForKey(model, key) {
    return this.getMetadata(model).find(function (_ref2) {
      var metaKey = _ref2[0];
      return metaKey === key;
    });
  };

  _proto.addMetadata = function addMetadata(model, metadata) {
    var existingMetadata = this._metadataMap.get(model) || [];
    var proto = Object.getPrototypeOf(model);
    var existingProtoMetadata = proto && !!proto.name ? this._metadataMap.get(proto) || [] : [];
    var existingMeta = [].concat(existingProtoMetadata, existingMetadata);

    for (var _iterator = _createForOfIteratorHelperLoose(existingMeta), _step; !(_step = _iterator()).done;) {
      var _step$value = _step.value,
          existKey = _step$value[0];
      var _metadata$ = metadata[0],
          key = _metadata$[0];

      if (key === existKey) {
        return;
      }
    }

    this._metadataMap.set(model, [].concat(existingMeta, metadata));
  };

  return MetadataStorage;
}();

var metadataStorage = /*#__PURE__*/new MetadataStorage();

/**
 * Internal ProfileStorage class
 *
 * @private
 */

var ProfileStorage = /*#__PURE__*/function () {
  function ProfileStorage() {
    this.profiles = new WeakMap();
  }
  /**
   * Initialize a Mapper instance with an empty profiles array
   *
   * @param {AutoMapper} mapper - Mapper instance to initialize
   */


  var _proto = ProfileStorage.prototype;

  _proto.initialize = function initialize(mapper) {
    this.profiles.set(mapper, []);
  }
  /**
   * Add a MappingProfile to a Mapper instance
   *
   * @param {AutoMapper} mapper - Mapper instance to initialize
   * @param {MappingProfile} profile - MappingProfile to add to the mapper instance
   */
  ;

  _proto.add = function add(mapper, profile) {
    var profiles = this.profiles.get(mapper);

    if (profiles.some(function (p) {
      return p.profileName === profile.profileName;
    })) {
      ErrorHandler.handleError(profile.profileName + " already exists on this mapper instance");
    }

    profiles.push(profile);
  };

  return ProfileStorage;
}();

var InstanceStorage = /*#__PURE__*/function (_MapNestedStorage) {
  _inheritsLoose(InstanceStorage, _MapNestedStorage);

  function InstanceStorage() {
    var _this;

    _this = _MapNestedStorage.call(this) || this;
    _this.recursiveCounts = new WeakMap();
    return _this;
  }

  var _proto = InstanceStorage.prototype;

  _proto.getDepthAndCount = function getDepthAndCount(parent, member) {
    return [this.get(parent, member), this.getCount(parent, member)];
  };

  _proto.setCount = function setCount(parent, member, count) {
    if (this.recursiveCounts.has(parent)) {
      this.recursiveCounts.get(parent).set(member, count);
    } else {
      this.setInternal(this.recursiveCounts, parent, member, count);
    }
  };

  _proto.resetCount = function resetCount(parent, member) {
    var _this$recursiveCounts;

    (_this$recursiveCounts = this.recursiveCounts.get(parent)) == null ? void 0 : _this$recursiveCounts.set(member, 0);
  };

  _proto.resetAllCount = function resetAllCount(model) {
    var _this$recursiveCounts2;

    (_this$recursiveCounts2 = this.recursiveCounts.get(model)) == null ? void 0 : _this$recursiveCounts2.clear();
  };

  _proto.getCount = function getCount(parent, member) {
    return this.getInternal(this.recursiveCounts, parent, member);
  };

  _proto.dispose = function dispose() {
    this.recursiveCounts = new WeakMap();
  };

  return InstanceStorage;
}(MapNestedStorage);

var instanceStorage = /*#__PURE__*/new InstanceStorage();

function storeMetadata(model, metaName, metaKey, metaValue) {
  switch (metaName) {
    case 'String':
    case 'Number':
    case 'Boolean':
      metadataStorage.addMetadata(model, [[metaKey, function () {
        return false;
      }]]);
      break;

    case 'Date':
      metadataStorage.addMetadata(model, [[metaKey, function () {
        return Date;
      }]]);
      break;

    case 'Array':
      metadataStorage.addMetadata(model, [[metaKey, function () {
        return [];
      }]]);
      break;

    default:
      metadataStorage.addMetadata(model, [[metaKey, function () {
        return metaValue;
      }]]);
      break;
  }
}

function isEmpty(value) {
  if (Array.isArray(value)) {
    return !value.length;
  }

  return !value || !Object.keys(value).length;
}

function isClass(fn) {
  var _fn$constructor;

  var typeOfFn = typeof fn;
  var constructorFnString = (_fn$constructor = fn.constructor) == null ? void 0 : _fn$constructor.toString();
  return (typeOfFn === 'object' || typeOfFn === 'function') && fn.constructor && (/^\s*function/.test(constructorFnString) || /^\s*class/.test(constructorFnString)) && constructorFnString.includes(fn.constructor.name);
}

function isThisMemberMap(mapFn) {
  for (var _len = arguments.length, types = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    types[_key - 1] = arguments[_key];
  }

  return types.some(function (type) {
    return mapFn[0
    /* type */
    ] === type;
  });
}

function get(object, defaultVal) {
  function _getInternal(object, path) {
    var _path = path.split('.').filter(Boolean);

    var _val = _path.reduce(function (obj, key) {
      return obj && obj[key];
    }, object);

    return _val != null ? _val : defaultVal;
  }

  for (var _len = arguments.length, paths = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    paths[_key - 2] = arguments[_key];
  }

  var val = _getInternal(object, paths[0]);

  for (var i = 1, len = paths.length; i < len; i++) {
    if (val != null) {
      val = _getInternal(val, paths[i]);
      continue;
    }

    val = _getInternal(object, paths[i]);
  }

  return val;
}

function getSourcePropertyKey(_ref, path) {
  var sourceNamingConvention = _ref[0],
      destinationNamingConvention = _ref[1];
  var splitPath = path.split('.');

  if (splitPath.length > 1) {
    return splitPath.map(function (key) {
      return getSourcePropertyKey([sourceNamingConvention, destinationNamingConvention], key);
    }).join('.');
  }

  var destNamingConvention = new destinationNamingConvention();
  var srcNamingConvention = new sourceNamingConvention();
  var keyParts = path.split(destNamingConvention.splittingExpression).filter(Boolean);
  return !keyParts.length ? path : srcNamingConvention.transformPropertyName(keyParts);
}

/**
 * https://github.com/IRCraziestTaxi/ts-simple-nameof
 * This implementation is copied from the linked library.
 *
 * Old implementation:
 *
 if (/^[^{]+?=>/gm.test(fnString)) {
    let value: string[];
    const _parts = fnString
      .replace(/(?:\s|;|{|}|\(|\)|)+/gm, '')
      .split(/=>(.+)/);
    const _returnPart = _parts[1];
    const _returnMatches = _returnPart.match(/return/g);

    if (_returnMatches?.length && _returnMatches.length > 1) {
      value = [_parts[0]].concat(
        ..._returnPart.split(/return(.+)/).filter(Boolean)
      );
    } else {
      value = _parts;
    }

    return getPathFromSelector(value);
  }
  return getPathFromSelector(
    fnString.replace(/(?:\s|function|;|{|}|\(|\)|)+/gm, '').split(/return(.+)/)
  );

  function getPathFromSelector(fnParts: string[]): string {
  const [, ...parts] = fnParts
    .join('')
    .split(new RegExp(`${fnParts[0]}\\.{1}`, 'g'))
    .filter(Boolean);

  if (parts.length === 1) {
    return parts.pop() as string;
  }

  return '';
}
 */
function getMemberPath(fn) {
  var fnString = fn.toString(); // ES6 prop selector:
  // "x => x.prop"

  if (fnString.includes('=>')) {
    return cleanseAssertionOperators(fnString.substring(fnString.indexOf('.') + 1));
  } // ES5 prop selector:
  // "function (x) { return x.prop; }"
  // webpack production build excludes the spaces and optional trailing semicolon:
  //   "function(x){return x.prop}"
  // FYI - during local dev testing i observed carriage returns after the curly brackets as well
  // Note by maintainer: See https://github.com/IRCraziestTaxi/ts-simple-nameof/pull/13#issuecomment-567171802 for
  // explanation of this regex.


  var matchRegex = /function\s*\(\w+\)\s*{[\r\n\s]*return\s+\w+\.((\w+\.)*(\w+))/i;
  var es5Match = fnString.match(matchRegex);

  if (es5Match) {
    return es5Match[1];
  }

  return '';
}

function cleanseAssertionOperators(parsedName) {
  return parsedName.replace(/[?!]/g, '').replace(/(?:\s|;|{|}|\(|\)|)+/gm, '');
}

function mapInitialize(defaultVal) {
  for (var _len = arguments.length, paths = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    paths[_key - 1] = arguments[_key];
  }

  return [6
  /* MapInitialize */
  , null, function (source) {
    return get.apply(void 0, [source, defaultVal].concat(paths));
  }];
}

function instantiate(model, defaultValue) {
  var metadata = metadataStorage.getMetadata(model);
  var instance = defaultValue ? Object.assign(new model(), defaultValue) : new model();

  if (isEmpty(metadata) || !metadata) {
    return instance;
  }

  var i = metadata.length;

  var _loop = function _loop() {
    var _metadata$i = metadata[i],
        key = _metadata$i[0],
        meta = _metadata$i[1];
    var value = instance[key];
    var metaResult = meta();

    if (!metaResult) {
      instance[key] = value != null ? value : undefined;
      return "continue";
    }

    if (Array.isArray(metaResult)) {
      instance[key] = value != null ? value : metaResult;
      return "continue";
    }

    if (metaResult.prototype.constructor.name === 'Date' || metaResult.prototype.constructor.name === 'Moment') {
      instance[key] = value != null ? new metaResult(value) : new metaResult();
      return "continue";
    }

    if (Array.isArray(value)) {
      instance[key] = value.map(function (v) {
        return instantiate(metaResult, v);
      });
      return "continue";
    }

    if (value == null && defaultValue != null) {
      instance[key] = value;
      return "continue";
    }

    if (value != null) {
      instance[key] = instantiate(metaResult, value);
      return "continue";
    }

    var _instanceStorage$getD = instanceStorage.getDepthAndCount(model, key),
        depth = _instanceStorage$getD[0],
        _instanceStorage$getD2 = _instanceStorage$getD[1],
        count = _instanceStorage$getD2 === void 0 ? 0 : _instanceStorage$getD2;

    if (depth === 0) {
      instance[key] = new metaResult();
      return "continue";
    }

    if (depth === count) {
      instanceStorage.resetCount(model, key);
      instance[key] = new metaResult();
      return "continue";
    }

    instanceStorage.setCount(model, key, count != null ? count + 1 : 1);
    instance[key] = instantiate(metaResult, value);
  };

  while (i--) {
    var _ret = _loop();

    if (_ret === "continue") continue;
  }

  instanceStorage.resetAllCount(model);
  return instance;
}

function initializeMappingProps(mapping) {
  var _mapping$ = mapping[0
  /* models */
  ],
      srcModel = _mapping$[0],
      destModel = _mapping$[1];
  var destination = instantiate(destModel);
  var source = instantiate(srcModel);
  var sourceProtoConstructor = Object.getPrototypeOf(source.constructor);

  if (sourceProtoConstructor.name) {
    source = Object.assign(source, instantiate(sourceProtoConstructor));
  }

  var sourceProto = Object.getPrototypeOf(source);
  var destinationPaths = getPathRecursive(destination);
  var _mapping$2 = mapping[1
  /* conventions */
  ],
      useUndefined = _mapping$2[0],
      sourceNamingConvention = _mapping$2[1],
      destinationNamingConvention = _mapping$2[2];
  var i = destinationPaths.length;

  while (i--) {
    var path = destinationPaths[i];
    var sourcePath = getSourcePropertyKey([sourceNamingConvention, destinationNamingConvention], path);
    var dottedSourcePaths = sourcePath.split('.');

    if (dottedSourcePaths.length > 1 && (!source.hasOwnProperty(dottedSourcePaths[0]) || source[dottedSourcePaths[0]] && isClass(source[dottedSourcePaths[0]]))) {
      continue;
    }

    var defaultVal = useUndefined ? undefined : null;

    if (!source.hasOwnProperty(sourcePath) && !sourceProto.hasOwnProperty(sourcePath)) {
      var _ret = function () {
        var convention = new sourceNamingConvention();

        var _sourcePath$split$fil = sourcePath.split(convention.splittingExpression).filter(Boolean).filter(function (p) {
          return p !== '.';
        }),
            first = _sourcePath$split$fil[0],
            paths = _sourcePath$split$fil.slice(1);

        if (!paths.length || !source.hasOwnProperty(first)) {
          return "continue";
        }

        var sourceMemberPath = [[first].concat(paths.map(function (p) {
          return convention.transformPropertyName([p]);
        })).join('.')];

        if (paths.length > 1) {
          sourceMemberPath.push([first].concat(convention.transformPropertyName(paths)).join('.'));
        }

        mapping[2
        /* props */
        ].push([path, Object.seal({
          paths: [path],
          transformation: {
            type: 6,
            preCond: undefined,
            mapFn: mapInitialize.apply(void 0, [defaultVal].concat(sourceMemberPath))
          }
        })]);
        return "continue";
      }();

      if (_ret === "continue") continue;
    }

    mapping[2
    /* props */
    ].push([path, Object.seal({
      paths: [path, sourcePath],
      transformation: {
        type: 6,
        preCond: undefined,
        mapFn: mapInitialize(defaultVal, sourcePath)
      }
    })]);
  }
}

function getPathRecursive(node, prefix, prev) {
  if (prefix === void 0) {
    prefix = '';
  }

  var result = prev || [];
  var keys = Object.getOwnPropertyNames(node);

  for (var i = 0, len = keys.length; i < len; i++) {
    var key = keys[i];
    var path = prefix + key;
    result.push(path);
    var child = node[key];

    if (typeof child === 'object') {
      var queue = [child];

      if (Array.isArray(child)) {
        queue = child;
      }

      for (var _iterator = _createForOfIteratorHelperLoose(queue), _step; !(_step = _iterator()).done;) {
        var childNode = _step.value;
        var childPaths = getPathRecursive(childNode, path + '.');

        for (var _iterator2 = _createForOfIteratorHelperLoose(childPaths), _step2; !(_step2 = _iterator2()).done;) {
          var childPath = _step2.value;
          result.push(childPath);
        }
      }
    }
  }

  return result;
}

function createMappingObject(source, destination, options, mappingStorage) {
  if (mappingStorage.has(source, destination)) {
    ErrorHandler.handleError("Mapping for source " + source.toString() + " and destination " + destination.toString() + " already exists");
  }

  var mapping = [[source, destination], [options.useUndefined, options.sourceMemberNamingConvention, options.destinationMemberNamingConvention], [], []];
  initializeMappingProps(mapping);
  mappingStorage.set(source, destination, mapping);
  return mapping;
}

function getMappingForDestination(destination, source, mappingStorage, isInherit) {
  if (isInherit === void 0) {
    isInherit = false;
  }

  var mapping = mappingStorage.get(source, destination);

  if (!mapping && !isInherit) {
    throw new Error("Mapping not found for source " + source.toString() + " and destination " + destination.toString());
  }

  return mapping;
}

function inheritBaseMapping(mapping, baseMapping) {
  var props = mapping[2
  /* props */
  ];
  var baseProps = baseMapping[2
  /* props */
  ];

  var _loop = function _loop(i, len) {
    var _baseProps$i = baseProps[i],
        basePropKey = _baseProps$i[0],
        baseProp = _baseProps$i[1];
    var propFromBase = Object.seal(_extends({}, baseProp));
    var existProp = props.find(function (_ref) {
      var pKey = _ref[0];
      return pKey === basePropKey;
    });

    if (existProp) {
      existProp[0] = basePropKey;
      existProp[1] = propFromBase;
    } else {
      props.push([basePropKey, propFromBase]);
    }
  };

  for (var i = 0, len = baseProps.length; i < len; i++) {
    _loop(i);
  }

  mapping[4
  /* bases */
  ] = [baseMapping[0
  /* models */
  ][0], baseMapping[0
  /* models */
  ][1]];
}

function initializeReverseMappingProps(mapping) {
  var model = instantiate(mapping[0
  /* models */
  ][0]);
  var proto = Object.getPrototypeOf(model);
  var reversedProps = [];
  var props = mapping[2
  /* props */
  ];
  var i = props.length;

  var _loop = function _loop() {
    var _props$i$ = props[i][1],
        paths = _props$i$.paths,
        transformation = _props$i$.transformation;
    var destPath = paths[0],
        sourcePath = paths[1];
    /**
     * 1: TransformationType.MapFrom
     * 4: TransformationType.MapWith
     */

    if (!sourcePath && transformation.type !== 1 && transformation.type !== 4) {
      return "continue";
    }

    var path = '';

    if (sourcePath) {
      path = sourcePath;
    } else {
      path = getMemberPath(transformation.mapFn[2
      /* fn */
      ]);
    }

    if (!model.hasOwnProperty(path) && !proto.hasOwnProperty(path) || reversedProps.some(function (_ref) {
      var propPath = _ref[0];
      return propPath === path;
    })) {
      return "continue";
    }

    reversedProps.push([path, Object.seal({
      paths: [path, destPath],
      transformation: {
        type: 6,
        preCond: undefined,
        mapFn: mapInitialize(mapping[1
        /* conventions */
        ][0] ? undefined : null, destPath)
      }
    })]);
  };

  while (i--) {
    var _ret = _loop();

    if (_ret === "continue") continue;
  }

  return reversedProps;
}

function createReverseMappingObject(mapping, mappingStorage) {
  var _mapping$ = mapping[0
  /* models */
  ],
      source = _mapping$[0],
      destination = _mapping$[1];
  var _mapping$2 = mapping[1
  /* conventions */
  ],
      useUndefined = _mapping$2[0],
      sourceConvention = _mapping$2[1],
      destinationConvention = _mapping$2[2];
  var bases = mapping[4
  /* bases */
  ];
  var reversedMapping = mappingStorage.get(destination, source);

  if (reversedMapping) {
    return reversedMapping;
  }

  reversedMapping = [[destination, source], [useUndefined, destinationConvention, sourceConvention], initializeReverseMappingProps(mapping), [], (bases == null ? void 0 : bases.slice().reverse()) || []];
  var reversedBaseMapping = getMappingForDestination(reversedMapping[4
  /* bases */
  ][1], reversedMapping[4
  /* bases */
  ][0], mappingStorage, true);

  if (reversedBaseMapping) {
    inheritBaseMapping(reversedMapping, reversedBaseMapping);
  }

  mappingStorage.set(destination, source, reversedMapping);
  return reversedMapping;
}

function createMapForMember(mapping, selector, _ref, fluentFunction) {
  var preCond = _ref[0],
      mapMemberFn = _ref[1];
  var memberPath = getMemberPath(selector);

  if (mapMemberFn == null) {
    mapMemberFn = preCond;
    preCond = undefined;
  }

  var sourcePath = ''; // 1: TransformationType.MapFrom
  // 4: TransformationType.MapWith

  if (isThisMemberMap(mapMemberFn, 1, 4)) {
    sourcePath = getMemberPath(mapMemberFn[1
    /* misc */
    ]);
  }

  var paths = !!sourcePath ? [memberPath, sourcePath] : [memberPath];
  var mappingProperty = Object.seal({
    paths: paths,
    transformation: {
      mapFn: mapMemberFn,
      type: mapMemberFn[0
      /* type */
      ],
      preCond: preCond
    }
  });
  var existProp = mapping[2
  /* props */
  ].find(function (_ref2) {
    var propName = _ref2[0];
    return propName === memberPath;
  });

  if (existProp != null) {
    existProp[1] = mappingProperty;
    return fluentFunction;
  }

  mapping[2
  /* props */
  ].push([memberPath, mappingProperty]);
  return fluentFunction;
}

function createReverseMapFluentFunction(mapping) {
  var reversedMapFluentFunction = {
    forPath: function forPath(selector) {
      for (var _len = arguments.length, functions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        functions[_key - 1] = arguments[_key];
      }

      return createMapForMember(mapping, selector, functions, reversedMapFluentFunction);
    },
    beforeMap: function beforeMap(action) {
      mapping[3
      /* actions */
      ][0] = action;
      return reversedMapFluentFunction;
    },
    afterMap: function afterMap(action) {
      mapping[3
      /* actions */
      ][1] = action;
      return reversedMapFluentFunction;
    }
  };
  return reversedMapFluentFunction;
}

function createMapFluentFunction(mapping, options, mappingStorage) {
  var _options$includeBase;

  if ((_options$includeBase = options.includeBase) == null ? void 0 : _options$includeBase.length) {
    var _options$includeBase2 = options.includeBase,
        baseSource = _options$includeBase2[0],
        baseDestination = _options$includeBase2[1];
    var baseMapping = getMappingForDestination(baseDestination, baseSource, mappingStorage, true);

    if (baseMapping != null) {
      inheritBaseMapping(mapping, baseMapping);
    }
  }

  var fluentFunction = {
    forMember: function forMember(selector) {
      for (var _len = arguments.length, functions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        functions[_key - 1] = arguments[_key];
      }

      return createMapForMember(mapping, selector, functions, fluentFunction);
    },
    beforeMap: function beforeMap(action) {
      mapping[3
      /* actions */
      ][0] = action;
      return fluentFunction;
    },
    afterMap: function afterMap(action) {
      mapping[3
      /* actions */
      ][1] = action;
      return fluentFunction;
    },
    reverseMap: function reverseMap() {
      return createReverseMapFluentFunction(createReverseMappingObject(mapping, mappingStorage));
    }
  };
  return fluentFunction;
}

function getMappingForNestedKey(destinationConstructor, destinationMemberKey, sourceConstructor, mappingStorage) {
  var keyMetadata = metadataStorage.getMetadataForKey(destinationConstructor, destinationMemberKey);
  var meta = keyMetadata[1]();

  if (!meta || Array.isArray(meta)) {
    throw new Error("Metadata for " + destinationMemberKey + " is a primitive or Array. Consider manual map this property");
  }

  var mapping = mappingStorage.get(sourceConstructor, meta);

  if (!mapping) {
    throw new Error("Mapping for " + destinationMemberKey + " cannot be found. Consider manual map this property with MapWith");
  }

  return mapping;
}

function getMapProps(args, skipUnmappedAssertion) {
  var destination = args[0];
  var defaultOptions = {
    skipUnmappedAssertion: skipUnmappedAssertion,
    beforeMap: undefined,
    afterMap: undefined
  };

  if (args.length === 1) {
    return [destination, defaultOptions];
  }

  if (args.length === 3) {
    return [destination, _extends({}, defaultOptions, args[2]), args[1]];
  }

  var temp = args[1];

  if ((typeof temp === 'function' || isClass(temp)) && !temp['beforeMap'] && !temp['afterMap']) {
    return [destination, defaultOptions, temp];
  }

  return [destination, _extends({}, defaultOptions, temp)];
}

function mapMember(mapFn, sourceObj, sourceMemberPath, destination, mappingStorage, defaultValue) {
  var value;
  /**
   * 0: TransformationType.Ignore
   * 1: TransformationType.MapFrom
   * 2: TransformationType.Condition
   * 3: TransformationType.FromValue
   * 4: TransformationType.MapWith
   * 5: TransformationType.ConvertUsing
   * 7: TransformationType.NullSubstitution
   */

  if (isThisMemberMap(mapFn, 7)) {
    value = mapFn[2
    /* fn */
    ](sourceObj, sourceMemberPath);
  } else if (isThisMemberMap(mapFn, 2)) {
    value = mapFn[2
    /* fn */
    ](sourceObj, defaultValue, sourceMemberPath);
  } else if (isThisMemberMap(mapFn, 1)) {
    value = mapFn[2
    /* fn */
    ](sourceObj, destination);
  } else if (isThisMemberMap(mapFn, 4)) {
    value = mapFn[2
    /* fn */
    ](sourceObj, mappingStorage);
  } else if (isThisMemberMap(mapFn, 5)) {
    value = mapFn[2
    /* fn */
    ](sourceObj);
  } else if (isThisMemberMap(mapFn, 3)) {
    value = mapFn[2
    /* fn */
    ]();
  } else if (isThisMemberMap(mapFn, 0)) {
    value = defaultValue;
  } else {
    var memberMapFunction = mapFn[2
    /* fn */
    ](sourceObj, sourceMemberPath);
    value = mapMember(memberMapFunction, sourceObj, sourceMemberPath, destination, mappingStorage, defaultValue);
  }

  return value;
}

function map(sourceObj, mapping, options, mappingStorage, isArrayMap) {
  if (isArrayMap === void 0) {
    isArrayMap = false;
  }

  var _mapping$ = mapping[0],
      sourceModel = _mapping$[0],
      destinationModel = _mapping$[1],
      _mapping$2 = mapping[1],
      useUndefined = _mapping$2[0],
      sourceConvention = _mapping$2[1],
      destinationConvention = _mapping$2[2],
      props = mapping[2],
      actions = mapping[3];
  /**
   * If sourceObj is a POJO (plain object)
   * then instantiate it to become an instance of sourceModel
   */

  if (!(sourceObj instanceof sourceModel)) {
    sourceObj = instantiate(sourceModel, sourceObj);
  }

  var defaultEmptyValue = useUndefined ? undefined : null;
  var beforeAction = actions[0],
      afterAction = actions[1];
  var skipUnmappedAssertion = options.skipUnmappedAssertion,
      beforeMap = options.beforeMap,
      afterMap = options.afterMap;
  var configKeys = [];
  var destination = instantiate(destinationModel);

  if (!isArrayMap) {
    if (beforeMap) {
      beforeMap(sourceObj, destination, _extends({}, mapping));
    } else if (beforeAction) {
      beforeAction(sourceObj, destination, _extends({}, mapping));
    }
  }

  var i = props.length;

  while (i--) {
    var _props$i = props[i],
        memberPath = _props$i[0],
        transformation = _props$i[1].transformation;
    configKeys.push(memberPath);

    if (transformation.preCond && !transformation.preCond[0](sourceObj)) {
      var _transformation$preCo;

      set(destination, memberPath, (_transformation$preCo = transformation.preCond[1]) != null ? _transformation$preCo : defaultEmptyValue);
      continue;
    }

    var sourceMemberPath = getSourcePropertyKey([sourceConvention, destinationConvention], memberPath); // 6: TransformationType.MapInitialize

    if (isThisMemberMap(transformation.mapFn, 6)) {
      var mapInitializeValue = transformation.mapFn[2
      /* fn */
      ](sourceObj);

      if (mapInitializeValue == null) {
        set(destination, memberPath, defaultEmptyValue);
        continue;
      }

      if (mapInitializeValue instanceof Date) {
        set(destination, memberPath, new Date(mapInitializeValue));
        continue;
      }

      if (Array.isArray(mapInitializeValue)) {
        var first = mapInitializeValue[0];

        if (typeof first !== 'object') {
          set(destination, memberPath, mapInitializeValue.slice());
          continue;
        }

        if (isEmpty(first)) {
          set(destination, memberPath, []);
          continue;
        }

        var nestedMapping = getMappingForNestedKey(destinationModel, memberPath, first.constructor, mappingStorage);
        set(destination, memberPath, mapArray(mapInitializeValue, nestedMapping, {
          skipUnmappedAssertion: options.skipUnmappedAssertion
        }, mappingStorage));
        continue;
      }

      if ((typeof mapInitializeValue === 'object' || typeof mapInitializeValue === 'function') && isClass(mapInitializeValue)) {
        var _nestedMapping = getMappingForDestination(get(destination, null, memberPath).constructor, mapInitializeValue.constructor, mappingStorage);

        set(destination, memberPath, map(mapInitializeValue, _nestedMapping, {
          skipUnmappedAssertion: options.skipUnmappedAssertion
        }, mappingStorage));
        continue;
      }

      set(destination, memberPath, mapInitializeValue);
      continue;
    }

    set(destination, memberPath, mapMember(transformation.mapFn, sourceObj, sourceMemberPath, destination, mappingStorage, defaultEmptyValue));
  }

  if (!isArrayMap) {
    if (afterMap) {
      afterMap(sourceObj, destination, _extends({}, mapping));
    } else if (afterAction) {
      afterAction(sourceObj, destination, _extends({}, mapping));
    }
  }

  if (!skipUnmappedAssertion) {
    var unmappedKeys = Object.keys(destination).filter(function (k) {
      return !configKeys.includes(k);
    });

    if (unmappedKeys.length > 0) {
      throw new Error("\nError mapping:\n- Source: " + sourceModel.toString() + "\n- Destination: " + destinationModel.toString() + "\n\nUnmapped properties:\n-------------------\n" + unmappedKeys.join(',\n') + "\n");
    }
  }

  return destination;
}
function mapArray(sourceArray, mapping, options, mappingStorage) {
  var destination = [];
  var beforeMap = options.beforeMap,
      afterMap = options.afterMap;

  if (beforeMap) {
    beforeMap(sourceArray, destination, _extends({}, mapping));
  }

  for (var i = 0, len = sourceArray.length; i < len; i++) {
    destination.push(map(sourceArray[i], mapping, {
      skipUnmappedAssertion: options.skipUnmappedAssertion
    }, mappingStorage, true));
  }

  if (afterMap) {
    afterMap(sourceArray, destination, _extends({}, mapping));
  }

  return destination;
}

var MetadataExplorer = /*#__PURE__*/function () {
  function MetadataExplorer() {}

  MetadataExplorer.explore = function explore(source, destination) {
    this.exploreInternal(source);
    this.exploreInternal(destination);
  };

  MetadataExplorer.exploreInternal = function exploreInternal(model) {
    if (!model.prototype || this.metadataTrackMap.has(model)) {
      return;
    }

    var factory = model[this.AUTOMAPPER_METADATA_FACTORY];

    if (!factory) {
      return;
    }

    var metadata = factory();
    var metadataEntries = Object.entries(metadata);
    var i = metadataEntries.length;

    if (!i) {
      return;
    }

    while (i--) {
      var _metadataEntries$i = metadataEntries[i],
          key = _metadataEntries$i[0],
          value = _metadataEntries$i[1];

      if (!value) {
        storeMetadata(model, 'String', key);
        continue;
      }

      var meta = value();
      var metaName = meta.prototype.constructor.name;
      storeMetadata(model, metaName, key, meta);
    }

    this.metadataTrackMap.set(model, 1);
  };

  return MetadataExplorer;
}();
MetadataExplorer.metadataTrackMap = /*#__PURE__*/new Map();
MetadataExplorer.AUTOMAPPER_METADATA_FACTORY = '__NARTC_AUTOMAPPER_METADATA_FACTORY';

var AutoMapper = /*#__PURE__*/function () {
  function AutoMapper() {
    this._mappingStorage = new MappingStorage();
    this._profileStorage = new ProfileStorage();
    this.setDefault();
  }
  /**
   * Provide global naming conventions and useUndefined to the models
   *
   * @param {AutoMapperGlobalSettings} settings
   */


  var _proto = AutoMapper.prototype;

  _proto.withGlobalSettings = function withGlobalSettings(settings) {
    var useUndefined = settings.useUndefined,
        skipUnmappedAssertion = settings.skipUnmappedAssertion,
        sourceNamingConvention = settings.sourceNamingConvention,
        destinationNamingConvention = settings.destinationNamingConvention,
        throwError = settings.throwError;
    this.defaultGlobalSettings[0] = useUndefined != null ? useUndefined : false;
    this.defaultGlobalSettings[1] = skipUnmappedAssertion != null ? skipUnmappedAssertion : false;

    if (sourceNamingConvention) {
      this.defaultGlobalSettings[2] = sourceNamingConvention;
    }

    if (destinationNamingConvention) {
      this.defaultGlobalSettings[3] = destinationNamingConvention;
    }

    if (throwError != null) {
      ErrorHandler.setShouldThrow(throwError);
    }

    return this;
  }
  /**
   * Add a Profile to this AutoMapper instance
   * @param {MappingProfile} profile
   */
  ;

  _proto.addProfile = function addProfile(profile) {
    this._profileStorage.add(this, new profile(this));

    return this;
  }
  /**
   * Create a mapping between a Source and a Destination with an optional Options
   *
   * @param {Constructible} source
   * @param {Constructible} destination
   * @param {CreateMapOptions} options - Provide inheritance and naming conventions for this Mapping
   */
  ;

  _proto.createMap = function createMap(source, destination, options) {
    MetadataExplorer.explore(source, destination);

    var mergeOptions = _extends({
      useUndefined: this.defaultGlobalSettings[0],
      sourceMemberNamingConvention: this.defaultGlobalSettings[2],
      destinationMemberNamingConvention: this.defaultGlobalSettings[3]
    }, options);

    var mapping = createMappingObject(source, destination, mergeOptions, this._mappingStorage);
    return createMapFluentFunction(mapping, mergeOptions, this._mappingStorage);
  };

  _proto.map = function map$1(sourceObj) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var _getMapProps = getMapProps(args, this.defaultGlobalSettings[1]),
        destination = _getMapProps[0],
        options = _getMapProps[1],
        source = _getMapProps[2];

    var mapping = getMappingForDestination(destination, source || sourceObj.constructor, this._mappingStorage);
    return map(sourceObj, mapping, options, this._mappingStorage);
  };

  _proto.mapAsync = function mapAsync(sourceObj) {
    var _this = this;

    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    var _getMapProps2 = getMapProps(args, this.defaultGlobalSettings[1]),
        destination = _getMapProps2[0],
        options = _getMapProps2[1],
        source = _getMapProps2[2];

    var mapping = getMappingForDestination(destination, source || sourceObj.constructor, this._mappingStorage);
    return Promise.resolve().then(function () {
      return map(sourceObj, mapping, options, _this._mappingStorage);
    });
  };

  _proto.mapArray = function mapArray$1(sourceArr) {
    if (!sourceArr.length) {
      return [];
    }

    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }

    var _getMapProps3 = getMapProps(args, this.defaultGlobalSettings[1]),
        destination = _getMapProps3[0],
        options = _getMapProps3[1],
        source = _getMapProps3[2];

    var mapping = getMappingForDestination(destination, source || sourceArr[0].constructor, this._mappingStorage);
    return mapArray(sourceArr, mapping, options, this._mappingStorage);
  };

  _proto.mapArrayAsync = function mapArrayAsync(sourceArr) {
    var _this2 = this;

    if (!sourceArr.length) {
      return Promise.resolve().then(function () {
        return [];
      });
    }

    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      args[_key4 - 1] = arguments[_key4];
    }

    var _getMapProps4 = getMapProps(args, this.defaultGlobalSettings[1]),
        destination = _getMapProps4[0],
        options = _getMapProps4[1],
        source = _getMapProps4[2];

    var mapping = getMappingForDestination(destination, source || sourceArr[0].constructor, this._mappingStorage);
    return Promise.resolve().then(function () {
      return mapArray(sourceArr, mapping, options, _this2._mappingStorage);
    });
  }
  /**
   * Retrieve the mapping of a Source and a Destination
   *
   * @param {Constructible} source
   * @param {Constructible} destination
   */
  ;

  _proto.getMapping = function getMapping(source, destination) {
    return this._mappingStorage.get(source, destination);
  }
  /**
   * Dispose of all Mappings and Profiles on the AutoMapper instance
   */
  ;

  _proto.dispose = function dispose() {
    this.setDefault();

    this._mappingStorage.dispose();

    instanceStorage.dispose();
  }
  /**
   * Retrieve the current instance of the MappingStorage on the AutoMapper instance
   */
  ;

  _proto.setDefault = function setDefault() {
    this._profileStorage.initialize(this);

    this.defaultGlobalSettings = [false, false, defaultNamingConvention, defaultNamingConvention];
  };

  _createClass(AutoMapper, [{
    key: "mappingStorage",
    get: function get() {
      return this._mappingStorage;
    }
    /**
     * Retrieve the current instance of the ProfileStorage on the AutoMapper instance
     */

  }, {
    key: "profileStorage",
    get: function get() {
      return this._profileStorage;
    }
  }]);

  return AutoMapper;
}();
var Mapper = /*#__PURE__*/new AutoMapper();

var createMapMetadata = function createMapMetadata(model, metadataOptions) {
  var entries = Object.entries(metadataOptions);
  var i = entries.length;

  if (!i) {
    return;
  }

  while (i--) {
    var _metadata$prototype;

    var _entries$i = entries[i],
        key = _entries$i[0],
        metadata = _entries$i[1];
    var metadataName = ((_metadata$prototype = metadata.prototype) == null ? void 0 : _metadata$prototype.constructor.name) || metadata.constructor.name;
    storeMetadata(model, metadataName, key, metadata);
  }
};

var AutoMap = function AutoMap(typeFn, depth) {
  if (depth === void 0) {
    depth = 0;
  }

  return function (target, propertyKey) {
    if (typeFn) {
      metadataStorage.addMetadata(target.constructor, [[propertyKey, typeFn]]);
      instanceStorage.set(target.constructor, propertyKey, depth);
    } else {
      var meta = Reflect.getMetadata('design:type', target, propertyKey);

      if (meta) {
        storeMetadata(target.constructor, meta.prototype.constructor.name, propertyKey);
      }
    }
  };
};

function mapFrom(from) {
  return [1, from, function (source, destination) {
    if (isResolver(from)) {
      return from.resolve(source, destination);
    }

    return from(source);
  }];
}

function isResolver(fn) {
  return 'resolve' in fn;
}

function mapWith(withDestination, withValue, valueModel) {
  return [4, withValue, function (source, mappingStorage) {
    var sourceValue = withValue(source);

    if (Array.isArray(sourceValue)) {
      if (isEmpty(sourceValue[0])) {
        return [];
      }

      var _mapping = getMappingForDestination(withDestination, (valueModel == null ? void 0 : valueModel()) || sourceValue[0].constructor, mappingStorage);

      return mapArray(sourceValue, _mapping, {
        skipUnmappedAssertion: true
      }, mappingStorage);
    }

    if (isEmpty(sourceValue)) {
      return null;
    }

    if (!isClass(sourceValue)) {
      console.warn("MapWith was invoked with a primitive. No mapping was executed");
      return null;
    }

    var mapping = getMappingForDestination(withDestination, (valueModel == null ? void 0 : valueModel()) || sourceValue.constructor, mappingStorage);
    return map(sourceValue, mapping, {
      skipUnmappedAssertion: true
    }, mappingStorage);
  }];
}

function condition(predicate, defaultValue) {
  return [2, null, function (source, internalDefaultValue) {
    if (predicate(source)) {
      for (var _len = arguments.length, sourceMemberPaths = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        sourceMemberPaths[_key - 2] = arguments[_key];
      }

      return get.apply(void 0, [source, internalDefaultValue].concat(sourceMemberPaths));
    }

    return defaultValue || internalDefaultValue;
  }];
}

function fromValue(rawValue) {
  // 3: TransformationType.FromValue
  return [3, null, function () {
    return rawValue;
  }];
}

function convertUsing(converter, value) {
  return [5, null, function (source) {
    var valueToConvert;

    if (value) {
      valueToConvert = value(source);
    } else {
      valueToConvert = source;
    }

    return converter.convert(valueToConvert);
  }];
}

function nullSubstitution(substitution) {
  return [7, null, function (source) {
    for (var _len = arguments.length, sourceMemberPaths = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      sourceMemberPaths[_key - 1] = arguments[_key];
    }

    return get.apply(void 0, [source, substitution].concat(sourceMemberPaths));
  }];
}

function preCondition(predicate, defaultValue) {
  return [function (source) {
    return predicate(source);
  }, defaultValue];
}

function ignore() {
  // 0: TransformationType.Ignore
  return [0, null, function () {}];
}

function mapDefer(defer) {
  // 8: TransformationType.MapDefer
  return [8, null, defer];
}

var ProfileBase = function ProfileBase() {
  this.profileName = this.constructor.name;
};

export { AutoMap, AutoMapper, CamelCaseNamingConvention, Mapper, PascalCaseNamingConvention, ProfileBase, SnakeCaseNamingConvention, condition, convertUsing, createMapMetadata, defaultNamingConvention, fromValue, ignore, mapDefer, mapFrom, mapWith, nullSubstitution, preCondition };
//# sourceMappingURL=automapper.esm.js.map
